<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Runner Papier Toilette</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

<style>
html,body{
  margin:0;
  height:100%;
  overflow:hidden;
  font-family: Arial, sans-serif;
  background:#87CEEB;
  touch-action: manipulation;
}

#hud{
  position:absolute;
  top:10px;
  left:10px;
  right:10px;
  display:flex;
  justify-content:space-between;
  z-index:10;
  font-weight:bold;
}

.hud-box{
  background:rgba(255,255,255,0.7);
  padding:6px 10px;
  border-radius:12px;
}

canvas{
  display:block;
  width:100%;
  height:80vh;
}

#controls{
  height:20vh;
  display:flex;
}

button{
  flex:1;
  font-size:26px;
  font-weight:bold;
  border:none;
  color:white;
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
  cursor: pointer;
}

#jump{ background:#34a853; }
#slide{ background:#f29900; }
button:active{ filter:brightness(0.9); }
</style>
</head>

<body>

<div id="hud">
  <div class="hud-box" id="score">Rouleaux: 0</div>
  <div class="hud-box" id="speed">Vitesse: 1.0x</div>
</div>

<canvas id="game"></canvas>

<div id="controls">
  <button id="jump">SAUT</button>
  <button id="slide">GLISSE</button>
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

let W,H;
function resize(){
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight * 0.8;
}
resize();
window.addEventListener("resize", resize);

// ✅ Sol recalculé dynamiquement (corrige le "rien ne se passe" sur mobile)
function groundY(){
  return H * 0.75;
}

// --- GAME VARIABLES ---
let gameTime = 0;
let speed = 200;
let speedMult = 1;
let score = 0;

// --- PLAYER ---
const player = {
  x: 80,
  y: groundY() - 60,
  w: 40,
  h: 60,
  vy: 0,
  onGround: true,
  sliding: false,
  slideTime: 0
};

// --- ENTITIES ---
const obstacles = [];
const rolls = [];

// --- CONTROLS (ultra réactif mobile) ---
function fastPress(btn, fn){
  btn.addEventListener("pointerdown", e => { e.preventDefault(); fn(); }, {passive:false});
  btn.addEventListener("touchstart", e => { e.preventDefault(); fn(); }, {passive:false});
}

fastPress(document.getElementById("jump"), ()=>{
  if(player.onGround){
    player.vy = -900;
    player.onGround = false;
    player.sliding = false;
  }
});

fastPress(document.getElementById("slide"), ()=>{
  if(player.onGround && !player.sliding){
    player.sliding = true;
    player.slideTime = 0.5;
  }
});

// --- SPAWN ---
let spawnTimer = 1.8;

function spawnObstacle(){
  obstacles.push({
    x: W,
    y: groundY() - 30,
    w: 30,
    h: 30
  });

  if(Math.random() < 0.6){
    rolls.push({
      x: W + 150,
      y: groundY() - 120,
      w: 30,
      h: 30
    });
  }
}

// --- UPDATE ---
function update(dt){
  gameTime += dt;

  // difficulty progression (démarre facile, monte progressivement)
  speedMult = 1 + gameTime * 0.05;
  speed = 200 * speedMult;
  document.getElementById("speed").textContent = "Vitesse: " + speedMult.toFixed(1) + "x";

  // gravity
  player.vy += 2200 * dt;
  player.y += player.vy * dt;

  if(player.y >= groundY() - player.h){
    player.y = groundY() - player.h;
    player.vy = 0;
    player.onGround = true;
  }

  if(player.sliding){
    player.slideTime -= dt;
    if(player.slideTime <= 0) player.sliding = false;
  }

  // spawn (plus lent au début, plus rapide ensuite)
  spawnTimer -= dt;
  if(spawnTimer <= 0){
    spawnObstacle();
    spawnTimer = Math.max(0.8, 1.8 - gameTime * 0.05);
  }

  obstacles.forEach(o => o.x -= speed * dt);
  rolls.forEach(r => r.x -= speed * dt);

  // collisions
  obstacles.forEach(o=>{
    if(o.x < player.x + player.w &&
       o.x + o.w > player.x &&
       o.y < player.y + (player.sliding ? 30 : player.h) &&
       o.y + o.h > (player.sliding ? groundY()-30 : player.y)){
      alert("Perdu !");
      location.reload();
    }
  });

  rolls.forEach((r,i)=>{
    if(r.x < player.x + player.w &&
       r.x + r.w > player.x &&
       r.y < player.y + (player.sliding ? 30 : player.h) &&
       r.y + r.h > (player.sliding ? groundY()-30 : player.y)){
      rolls.splice(i,1);
      score++;
      document.getElementById("score").textContent = "Rouleaux: " + score;
    }
  });
}

// --- DRAW ---
function draw(){
  ctx.clearRect(0,0,W,H);

  // background sky
  const grad = ctx.createLinearGradient(0,0,0,H);
  grad.addColorStop(0,"#6ec6ff");
  grad.addColorStop(1,"#dff6ff");
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,W,H);

  // ground
  ctx.fillStyle="#4caf50";
  ctx.fillRect(0, groundY(), W, H - groundY());

  // player (un seul bonhomme)
  ctx.fillStyle="#1e88e5";
  ctx.fillRect(
    player.x,
    player.sliding ? groundY()-30 : player.y,
    player.w,
    player.sliding ? 30 : player.h
  );

  // obstacles
  ctx.fillStyle="#6d4c41";
  obstacles.forEach(o=>ctx.fillRect(o.x,o.y,o.w,o.h));

  // rolls
  ctx.fillStyle="#fff";
  rolls.forEach(r=>ctx.fillRect(r.x,r.y,r.w,r.h));
}

// --- LOOP ---
let last = performance.now();
function loop(now){
  const dt = Math.min((now-last)/1000,0.033);
  last = now;

  update(dt);
  draw();
  requestAnimationFrame(loop);
}

// ✅ sécurité : remet le joueur au bon endroit si la taille change
window.addEventListener("resize", ()=>{
  player.y = Math.min(player.y, groundY() - player.h);
});

requestAnimationFrame(loop);
</script>
</body>
</html>
```0
