<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Runner Papier Toilette</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
html,body{
  margin:0;
  height:100%;
  overflow:hidden;
  font-family: Arial, sans-serif;
  background:#87CEEB;
  touch-action: manipulation;
}
#hud{
  position:absolute;
  top:10px;
  left:10px;
  right:10px;
  display:flex;
  justify-content:space-between;
  z-index:10;
  font-weight:bold;
}
.hud-box{
  background:rgba(255,255,255,0.75);
  padding:6px 12px;
  border-radius:14px;
}
canvas{
  display:block;
  width:100%;
  height:80vh;
}
#controls{
  height:20vh;
  display:flex;
}
button{
  flex:1;
  font-size:26px;
  font-weight:bold;
  border:none;
  color:white;
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
  user-select:none;
  -webkit-user-select:none;
}
#jump{ background:#34a853; }
#slide{ background:#f29900; }
button:active{ filter:brightness(0.9); }
</style>
</head>

<body>
<div id="hud">
  <div class="hud-box" id="score">Rouleaux: 0</div>
  <div class="hud-box" id="speed">Vitesse: 1.0x</div>
</div>

<canvas id="game"></canvas>

<div id="controls">
  <button id="jump">SAUT</button>
  <button id="slide">GLISSE</button>
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

let W,H;
function resize(){
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight * 0.8;
}
resize();
window.addEventListener("resize", resize);

// Sol dynamique
function groundY(){ return H * 0.75; }

// --- GAME ---
let gameTime = 0;
let speedMult = 1;
let speed = 200;
let score = 0;

// --- PLAYER ---
const player = {
  x: 80,
  y: groundY() - 70,
  w: 44,
  h: 70,
  vy: 0,
  onGround: true,
  sliding: false,
  slideTime: 0
};

// --- ENTITIES ---
const obstacles = []; // {x,y,w,h,type:'ground'|'air'}
const rolls = [];

// --- CONTROLS helpers ---
function onPress(btn, startFn, endFn){
  // pointer events
  btn.addEventListener("pointerdown", e => { e.preventDefault(); startFn(e); }, {passive:false});
  btn.addEventListener("pointerup",   e => { e.preventDefault(); endFn(e); },   {passive:false});
  btn.addEventListener("pointercancel", e => { e.preventDefault(); endFn(e); }, {passive:false});

  // fallback touch
  btn.addEventListener("touchstart", e => { e.preventDefault(); startFn(e); }, {passive:false});
  btn.addEventListener("touchend",   e => { e.preventDefault(); endFn(e); },   {passive:false});
  btn.addEventListener("touchcancel", e => { e.preventDefault(); endFn(e); },  {passive:false});
}

// --- VARIABLE JUMP (press duration) ---
let jumpHolding = false;
let jumpHoldStart = 0;

// réglages saut variable
const JUMP_MIN_VEL = 720;   // petit saut (appui bref)
const JUMP_MAX_VEL = 1150;  // grand saut (appui long)
const JUMP_MAX_HOLD = 0.35; // secondes pour atteindre le saut max

const jumpBtn = document.getElementById("jump");
const slideBtn = document.getElementById("slide");

onPress(
  jumpBtn,
  () => {
    // start hold
    if(player.onGround){
      jumpHolding = true;
      jumpHoldStart = performance.now();
    }
  },
  () => {
    // release -> jump strength depends on hold duration
    if(player.onGround && jumpHolding){
      const held = Math.min((performance.now() - jumpHoldStart) / 1000, JUMP_MAX_HOLD);
      const t = held / JUMP_MAX_HOLD; // 0..1
      const vel = JUMP_MIN_VEL + (JUMP_MAX_VEL - JUMP_MIN_VEL) * t;

      player.vy = -vel;
      player.onGround = false;
      player.sliding = false;
    }
    jumpHolding = false;
  }
);

// --- SLIDE ---
function doSlide(){
  if(player.onGround && !player.sliding){
    player.sliding = true;
    player.slideTime = 0.55;
  }
}

slideBtn.addEventListener("pointerdown", e => { e.preventDefault(); doSlide(); }, {passive:false});
slideBtn.addEventListener("touchstart",  e => { e.preventDefault(); doSlide(); }, {passive:false});

// --- SPAWN ---
let spawnTimer = 2.0;

function spawnObstacle(){
  const air = Math.random() < 0.40; // 40% en l'air

  if(air){
    const w = 34, h = 28;
    const y = groundY() - 92; // obstacle en l'air -> glisser dessous
    obstacles.push({ x: W, y, w, h, type: "air" });
  } else {
    const w = 34, h = 34;
    const y = groundY() - h; // obstacle au sol -> sauter
    obstacles.push({ x: W, y, w, h, type: "ground" });
  }

  // rouleaux un peu plus haut pour encourager le saut
  if(Math.random() < 0.65){
    rolls.push({ x: W + 160, y: groundY() - 150, w: 34, h: 34 });
  }
}

// --- UPDATE ---
function update(dt){
  gameTime += dt;

  // difficulté progressive
  speedMult = 1 + gameTime * 0.04;
  speed = 190 * speedMult;
  document.getElementById("speed").textContent = "Vitesse: " + speedMult.toFixed(1) + "x";

  // physique
  player.vy += 2350 * dt;
  player.y += player.vy * dt;

  if(player.y >= groundY() - player.h){
    player.y = groundY() - player.h;
    player.vy = 0;
    player.onGround = true;
  }

  if(player.sliding){
    player.slideTime -= dt;
    if(player.slideTime <= 0) player.sliding = false;
  }

  // spawn progressif
  spawnTimer -= dt;
  if(spawnTimer <= 0){
    spawnObstacle();
    spawnTimer = Math.max(0.85, 2.0 - gameTime * 0.05);
  }

  obstacles.forEach(o => o.x -= speed * dt);
  rolls.forEach(r => r.x -= speed * dt);

  // hitbox (slide)
  const pTop = player.sliding ? (groundY() - 34) : player.y;
  const pH   = player.sliding ? 34 : player.h;

  // collisions obstacle
  obstacles.forEach(o=>{
    if(o.x < player.x + player.w &&
       o.x + o.w > player.x &&
       o.y < pTop + pH &&
       o.y + o.h > pTop){
      alert("Perdu !");
      location.reload();
    }
  });

  // collisions rouleaux
  rolls.forEach((r,i)=>{
    if(r.x < player.x + player.w &&
       r.x + r.w > player.x &&
       r.y < player.y + player.h &&
       r.y + r.h > player.y){
      rolls.splice(i,1);
      score++;
      document.getElementById("score").textContent = "Rouleaux: " + score;
    }
  });

  // nettoyage
  while(obstacles.length && obstacles[0].x + obstacles[0].w < -50) obstacles.shift();
  while(rolls.length && rolls[0].x + rolls[0].w < -50) rolls.shift();
}

// --- DRAW ---
function draw(){
  ctx.clearRect(0,0,W,H);

  // ciel
  const sky = ctx.createLinearGradient(0,0,0,H);
  sky.addColorStop(0,"#6ec6ff");
  sky.addColorStop(1,"#eaf8ff");
  ctx.fillStyle = sky;
  ctx.fillRect(0,0,W,H);

  // nuages
  drawCloud(W*0.15, H*0.12, 1.0);
  drawCloud(W*0.55, H*0.18, 1.25);
  drawCloud(W*0.82, H*0.10, 0.9);

  // sol
  ctx.fillStyle="#49c880";
  ctx.fillRect(0, groundY(), W, H - groundY());

  // obstacles
  obstacles.forEach(o=>{
    if(o.type === "air"){
      ctx.save();
      ctx.globalAlpha = 0.15;
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.ellipse(o.x + o.w/2, o.y + o.h/2, o.w*0.75, o.h*0.75, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
    drawPoop(o.x,o.y,o.w,o.h);
  });

  // rouleaux
  rolls.forEach(r=>drawRoll(r.x,r.y,r.w,r.h));

  // joueur
  drawRunner(
    player.x,
    player.sliding ? (groundY()-34) : player.y,
    player.sliding
  );

  // petit indicateur visuel pendant le hold (optionnel mais utile)
  if(jumpHolding && player.onGround){
    const held = Math.min((performance.now() - jumpHoldStart) / 1000, JUMP_MAX_HOLD);
    const t = held / JUMP_MAX_HOLD;
    ctx.save();
    ctx.globalAlpha = 0.85;
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    roundRect(player.x-10, groundY()-100, 70, 10, 6, true);
    ctx.fillStyle = "rgba(0,0,0,0.15)";
    roundRect(player.x-10, groundY()-100, 70, 10, 6, true);
    ctx.fillStyle = "rgba(52,168,83,0.95)";
    roundRect(player.x-10, groundY()-100, 70*t, 10, 6, true);
    ctx.restore();
  }
}

// --- DRAW HELPERS ---
function drawRunner(x, y, sliding){
  ctx.save();
  ctx.translate(x, y);

  const now = performance.now();
  const step = Math.sin(now/110) * (sliding ? 1 : 6);

  const bodyW = sliding ? 58 : 44;
  const bodyH = sliding ? 34 : 70;

  // ombre
  ctx.globalAlpha = 0.18;
  ctx.fillStyle = "#000";
  ctx.beginPath();
  ctx.ellipse(bodyW/2, bodyH+10, 22, 7, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.globalAlpha = 1;

  // jambes
  ctx.strokeStyle = "rgba(20,20,20,.75)";
  ctx.lineWidth = 4;
  ctx.lineCap = "round";
  if(!sliding){
    ctx.beginPath(); ctx.moveTo(16, bodyH-6); ctx.lineTo(10-step, bodyH+10); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(28, bodyH-6); ctx.lineTo(34+step, bodyH+10); ctx.stroke();
  } else {
    ctx.beginPath(); ctx.moveTo(16, bodyH-2); ctx.lineTo(40, bodyH-2); ctx.stroke();
  }

  // corps
  ctx.fillStyle = "#1e88e5";
  roundRect(10, 24, bodyW-20, bodyH-30, 12, true);

  // tête
  ctx.fillStyle = "#ffe0bd";
  ctx.beginPath();
  ctx.arc(bodyW/2, 16, 12, 0, Math.PI*2);
  ctx.fill();

  // cheveux
  ctx.fillStyle = "rgba(35,35,35,.9)";
  ctx.beginPath();
  ctx.arc(bodyW/2, 15, 12, Math.PI, 0);
  ctx.fill();

  // yeux
  ctx.fillStyle = "rgba(0,0,0,.7)";
  ctx.beginPath(); ctx.arc(bodyW/2 - 5, 16, 1.7, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(bodyW/2 + 5, 16, 1.7, 0, Math.PI*2); ctx.fill();

  // bouche
  ctx.strokeStyle = "rgba(0,0,0,.35)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(bodyW/2, 20, 5, 0.1*Math.PI, 0.9*Math.PI);
  ctx.stroke();

  // bras
  if(!sliding){
    const arm = Math.cos(now/120) * 5;
    ctx.strokeStyle = "rgba(20,20,20,.75)";
    ctx.lineWidth = 4;
    ctx.beginPath(); ctx.moveTo(12, 34); ctx.lineTo(8-arm, 46); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(bodyW-12, 34); ctx.lineTo(bodyW-8+arm, 46); ctx.stroke();
  }

  ctx.restore();
}

function drawPoop(x,y,w,h){
  ctx.save(); ctx.translate(x,y);
  ctx.fillStyle="#7a4a21";
  roundRect(0, h*0.45, w, h*0.55, 10, true);
  roundRect(w*0.14, h*0.2, w*0.72, h*0.35, 10, true);
  roundRect(w*0.28, 0, w*0.44, h*0.25, 10, true);
  ctx.globalAlpha = 0.2;
  ctx.fillStyle = "#fff";
  ctx.beginPath();
  ctx.ellipse(w*0.30, h*0.68, 5, 9, 0.6, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();
}

function drawRoll(x,y,w,h){
  ctx.save(); ctx.translate(x+w/2, y+h/2);
  ctx.fillStyle="rgba(255,255,255,0.96)";
  roundRect(-w/2, -h/2, w, h, 10, true);
  ctx.fillStyle="rgba(200,200,200,0.95)";
  ctx.beginPath();
  ctx.ellipse(0, 0, 8, 7, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.fillStyle="rgba(255,255,255,0.92)";
  roundRect(w/2 - 6, 5, 18, 12, 6, true);
  ctx.restore();
}

function drawCloud(x,y,s){
  ctx.save();
  ctx.translate(x,y);
  ctx.scale(s,s);
  ctx.fillStyle="rgba(255,255,255,0.85)";
  ctx.beginPath();
  ctx.arc(0, 0, 18, 0, Math.PI*2);
  ctx.arc(18, -8, 22, 0, Math.PI*2);
  ctx.arc(38, 0, 18, 0, Math.PI*2);
  ctx.arc(18, 10, 20, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();
}

function roundRect(x,y,w,h,r,fill){
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
  if(fill) ctx.fill();
}

// --- LOOP ---
let last = performance.now();
function loop(now){
  const dt = Math.min((now-last)/1000, 0.033);
  last = now;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// sécurité resize
window.addEventListener("resize", ()=>{
  player.y = Math.min(player.y, groundY() - player.h);
});
</script>
</body>
</html>
```0
